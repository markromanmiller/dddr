% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quat-operations.R
\name{quat_equal}
\alias{quat_equal}
\alias{vec_proxy_equal.dddr_quat}
\alias{all.equal.dddr_quat}
\alias{compare_proxy.dddr_quat}
\title{Quaternion equality}
\usage{
\method{vec_proxy_equal}{dddr_quat}(x, ...)

\method{all.equal}{dddr_quat}(target, current, ...)

compare_proxy.dddr_quat(x, path)
}
\arguments{
\item{x}{Quaternions to form a proxy for.}

\item{...}{arguments passed on the underlying function for all.equal}

\item{target, current}{quaternions to compare}

\item{path}{Path describing the proxy operation}
}
\description{
Like most mathematical objects, there is a notion of equality on quaternions.
Because the focus here is on using quaternions to rotate, quaternions are
considered equal if they produce the same rotation.
}
\details{
In particular, if all entries in a quaternion are negated, the result is the
same exact rotation. This is known as "double cover." In this case, the
quaternions (w,x,y,z) and (-w,-x,-y,-z) are considered equal.

The assorted proxy methods create a data frame that shows where the unit x
and unit y vectors are mapped in 3d space. This is more numerically stable
than normalizing based on e.g. sign of w.
}
